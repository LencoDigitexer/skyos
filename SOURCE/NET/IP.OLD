/************************************************************************/
/* Sky Operating System V2
/* Copyright (c) 1996 by Szeleney Robert
/*
/* Project Members: Szeleney Robert
/*                  Resl Christian
/*                  Hayrapetian Gregory
/************************************************************************/
/* File       : net\ip.c
/* Last Update: 25.11.1998
/* Version    : alpha
/* Coded by   : Szeleney Robert
/* Docus      : Internet, Linux
/*              IP:   760
/*              ICMP: 777
/************************************************************************/
/* Definition:
/*   Internet Protocol Driver.
/************************************************************************/
#include "netdev.h"
#include "ip.h"

#define NULL (void*)0

#define ETH_P_IP	0x0800		/* Internet Protocol packet	*/

unsigned int ip_count = 0;

extern unsigned int protman_icmp_debug ;

static unsigned short int ntohs(unsigned short int x)
{
	__asm__("xchgb %b0,%h0"		/* swap bytes		*/
		: "=q" (x)
		:  "0" (x));
	return x;
}

static unsigned short int htons(unsigned short int x)
{
	__asm__("xchgb %b0,%h0"		/* swap bytes		*/
		: "=q" (x)
		:  "0" (x));
	return x;
}

extern struct s_net_device *active_device;


void ip_dump(struct s_iphdr *ip)
{
  unsigned char buff[32];
  unsigned char *ptr;
  struct s_icmphdr *icmp;
  int addr, len, i;

  /* Dump the IP header. */
  printk("IP: ihl=%d, version=%d, tos=%d, tot_len=%d\n",
	   ip->ihl, ip->version, ip->tos, ntohs(ip->tot_len));
  printk("    id=%X, ttl=%d, prot=%d, check=%X\n",
	   ip->id, ip->ttl, ip->protocol, ip->check);
  printk("    frag_off=%d\n", ip->frag_off);
  printk("    soucre=%s ", in_ntoa(ip->saddr));
  printk("dest=%s\n", in_ntoa(ip->daddr));
}

void icmp_dump(struct s_icmphdr *icmp)
{
    printk("ICMP Header:");
    printk("Typ: %d  Code: %d    Checksum: %0004X",icmp->type, icmp->code, icmp->checksum);
}

/* This is a version of ip_compute_csum() optimized for IP headers, which
   always checksum on 4 octet boundaries. */
static inline unsigned short
ip_fast_csum(unsigned char * buff, int wlen)
{
    unsigned long sum = 0;

    if (wlen) {
    	unsigned long bogus;
	 __asm__("clc\n"
		"1:\t"
		"lodsl\n\t"
		"adcl %3, %0\n\t"
		"decl %2\n\t"
		"jne 1b\n\t"
		"adcl $0, %0\n\t"
		"movl %0, %3\n\t"
		"shrl $16, %3\n\t"
		"addw %w3, %w0\n\t"
		"adcw $0, %w0"
	    : "=r" (sum), "=S" (buff), "=r" (wlen), "=a" (bogus)
	    : "0"  (sum),  "1" (buff),  "2" (wlen));
    }
    return (~sum) & 0xffff;
}

/*
 * This routine does all the checksum computations that don't
 * require anything special (like copying or special headers).
 */
unsigned short
ip_compute_csum(unsigned char * buff, int len)
{
  unsigned long sum = 0;

  /* Do the first multiple of 4 bytes and convert to 16 bits. */
  if (len > 3) {
	__asm__("clc\n"
	        "1:\t"
	    	"lodsl\n\t"
	    	"adcl %%eax, %%ebx\n\t"
	    	"loop 1b\n\t"
	    	"adcl $0, %%ebx\n\t"
	    	"movl %%ebx, %%eax\n\t"
	    	"shrl $16, %%eax\n\t"
	    	"addw %%ax, %%bx\n\t"
	    	"adcw $0, %%bx"
	        : "=b" (sum) , "=S" (buff)
	        : "0" (sum), "c" (len >> 2) ,"1" (buff)
	        : "ax", "cx", "si", "bx" );
  }
  if (len & 2) {
	__asm__("lodsw\n\t"
	    	"addw %%ax, %%bx\n\t"
	    	"adcw $0, %%bx"
	        : "=b" (sum), "=S" (buff)
	        : "0" (sum), "1" (buff)
	        : "bx", "ax", "si");
  }
  if (len & 1) {
	__asm__("lodsb\n\t"
	    	"movb $0, %%ah\n\t"
	    	"addw %%ax, %%bx\n\t"
	    	"adcw $0, %%bx"
	        : "=b" (sum), "=S" (buff)
	        : "0" (sum), "1" (buff)
	        : "bx", "ax", "si");
  }
  sum =~sum;
  return(sum & 0xffff);
}

/* check the header of an incoming IP datagram. */
int
ip_csum(struct s_iphdr *iph)
{
  return ip_fast_csum((unsigned char *)iph, iph->ihl);
}

static void ip_send_check(struct s_iphdr *iph)
{
   iph->check = 0;
   iph->check = ip_fast_csum((unsigned char *)iph, iph->ihl);
}

/*
 * This routine builds the appropriate hardware/IP headers for
 * the routine.  It assumes that if *dev != NULL then the
 * protocol knows what it's doing, otherwise it uses the
 * routing/ARP tables to select a device struct.
 */
struct s_net_buff*
ip_build_header(unsigned long saddr, unsigned long daddr,
		struct s_net_device *dev, int type, int len, int tos, int ttl)
{
  struct s_iphdr *iphdr;
  struct s_net_buff *buff;
  struct s_ethhdr *ethhdr;

  if (saddr == 0) 
  	saddr = dev->pa_addr;

  buff = (struct s_net_buff*)net_buff_alloc(len + sizeof(struct s_iphdr) +
    sizeof(struct s_ethhdr));

/* First, build the MAC header. */
  ethhdr = (struct s_ethhdr*)buff->data;

  /* Insert source hardware address (local machine address) */
  memcpy(ethhdr->h_source, dev->dev_addr, 6);

  /* Ask ARP-Cache for the destination address. This address must be known
     already. */

  if (!arp_get_mac(daddr, ethhdr->h_dest))
  {
    printk("ip.c: FATAL Error! No hardware address for destination");
    printk("      IP Address %s",in_ntoa(daddr));
    return NULL;
  }

  /* Insert Protocol type */
  ethhdr->h_proto = htons(ETH_P_IP);

/* Ok, MAC header set up. Now build the IP header */

  iphdr = (struct s_iphdr *)(buff->data + sizeof(struct s_ethhdr));
  iphdr->version  = 4;
  iphdr->tos      = tos;
  iphdr->frag_off = 0;
  iphdr->ttl      = ttl;
  iphdr->daddr    = daddr;
  iphdr->saddr    = saddr;
  iphdr->protocol = type;
  iphdr->ihl      = 5;
  iphdr->id       = htons(ip_count++);
  iphdr->tot_len  = htons(len + 20);

  ip_send_check(iphdr);

  return buff;
}

unsigned int htonl(unsigned long int x)
{
	__asm__("xchgb %b0,%h0\n\t"	/* swap lower bytes	*/
		"rorl $16,%0\n\t"	/* swap words		*/
		"xchgb %b0,%h0"		/* swap higher bytes	*/
		:"=q" (x)
		: "0" (x));
	return x;
}

unsigned long in_aton(const char *str)
{
	unsigned long l;
	unsigned int val;
	int i;

	l = 0;
	for (i = 0; i < 4; i++) 
	{
		l <<= 8;
		if (*str != '\0') 
		{
			val = 0;
			while (*str != '\0' && *str != '.') 
			{
				val *= 10;
				val += *str - '0';
				str++;
			}
			l |= val;
			if (*str != '\0') 
				str++;
		}
	}
	return(htonl(l));
}

void ip_init(void)
{
  struct s_net_device *act;

  act = active_device;

  // Test IP Address: 193.170.156.76
  act->pa_addr = 76 << 24;
  act->pa_addr += 156 << 16;
  act->pa_addr += 170 << 8;
  act->pa_addr += 193;

  printk("ip.c: Local IP Address: %s", in_ntoa(act->pa_addr));
}

void ip_config(unsigned char*str)
{
  struct s_net_device *act;

  act = active_device;

  // Test IP Address: 193.170.156.76
  act->pa_addr = in_aton(str);

  printk("ip.c: Local IP Address: %s", in_ntoa(act->pa_addr));
}

// ICMP

void icmp_echo_reply(struct s_net_buff *buff, struct s_net_device *dev)
{
  struct s_net_buff *send_buff;

  struct s_iphdr *iphdr_source;
  struct s_iphdr *iphdr_dest;
  struct s_ethhdr *ethhdr_source;
  struct s_ethhdr *ethhdr_dest;
  struct s_icmphdr *icmphdr_source;
  struct s_icmphdr *icmphdr_dest;
  unsigned short oldcheck, checksum;
  unsigned int len = 0;
  unsigned int i;

  ethhdr_source = (struct s_ethhdr*)(buff->data);
  iphdr_source = (struct s_iphdr*)(buff->data + sizeof(struct s_ethhdr));
  icmphdr_source = (struct s_icmphdr*)(buff->data + sizeof(struct s_ethhdr) +
    20);

/*  printk("icmp_echo_reply: alloc %d bytes.",htons(iphdr_source->tot_len));
  printk("                 checksum: 0x%0004X",icmphdr_source->checksum);*/

  oldcheck = icmphdr_source->checksum;
  icmphdr_source->checksum = 0;

  checksum = ip_compute_csum((unsigned char *)icmphdr_source,
                         htons(iphdr_source->tot_len) - 20);

  if (checksum != oldcheck)
  {
    printk("ip.c: Corrupt ICMP packet received.");
    return;
  }

  send_buff = (struct s_net_buff*)net_buff_alloc(htons(iphdr_source->tot_len) +
    sizeof(struct s_ethhdr));

  // copy received packet to send packet
  memcpy(send_buff->data, buff->data,
     htons(iphdr_source->tot_len) + sizeof(struct s_ethhdr));

  ethhdr_dest = (struct s_ethhdr*)(send_buff->data);
  iphdr_dest = (struct s_iphdr*)(send_buff->data + sizeof(struct s_ethhdr));
  icmphdr_dest = (struct s_icmphdr*)(send_buff->data + sizeof(struct s_ethhdr)
   + 20);

  // Build MAC header
  memcpy(ethhdr_dest->h_dest, ethhdr_source->h_source, 6);
  memcpy(ethhdr_dest->h_source, ethhdr_source->h_dest, 6);
  ethhdr_dest->h_proto = ethhdr_source->h_proto;

  // Build IP header
  iphdr_dest->version  = 4;
  iphdr_dest->tos      = 0;
  iphdr_dest->frag_off = 0;
  iphdr_dest->ttl      = 32;
  iphdr_dest->daddr    = iphdr_source->saddr;
  iphdr_dest->saddr    = iphdr_source->daddr;
  iphdr_dest->protocol = 0x01;                  //ICMP Message
  iphdr_dest->ihl      = 5;
  iphdr_dest->id       = htons(ip_count++);
  iphdr_dest->tot_len  = iphdr_source->tot_len;

  ip_send_check(iphdr_dest);

  // Build ICMP Header
  icmphdr_dest->type = 0;
  icmphdr_dest->code = 0;
  icmphdr_dest->checksum = 0;

  icmphdr_dest->checksum = ip_compute_csum((unsigned char *)icmphdr_dest,
                         htons(iphdr_source->tot_len) - 20);


  el3_start_xmit(dev, send_buff);
}

void icmp_echo_request(unsigned char *da, struct s_net_device *dev, unsigned int checksum, unsigned int deb)
{
  struct s_net_buff *send_buff;
  struct s_icmphdr *icmphdr;
  unsigned int daddr;

  daddr = in_aton(da);

  printk("ip.c: icmp_echo_request() sending to %s",in_ntoa(daddr));

  send_buff = (struct s_net_buff*)ip_build_header(dev->pa_addr, daddr,
		dev, 0x01, 32+20+80, 0, 32);

  icmphdr = (struct s_icmphdr*)(send_buff->data + sizeof(struct s_ethhdr) +
    20);

  icmphdr->type = 8;
  icmphdr->code = 0;
  icmphdr->checksum = checksum;

  if (deb)
  {
    memory_dump(send_buff->data, 100);
    ip_dump(send_buff->data + sizeof(struct s_ethhdr));
    icmp_dump(send_buff->data + sizeof(struct s_ethhdr) + 20);
  }

  el3_start_xmit(dev, send_buff);
}

void icmp_rcv(struct s_net_buff *buff, struct s_net_device *dev)
{
  struct s_icmphdr *icmphdr;
  struct s_iphdr   *iphdr;

  iphdr = (struct s_iphdr*)(buff->data + sizeof(struct s_ethhdr));
  icmphdr = (struct s_icmphdr*)(buff->data + sizeof(struct s_ethhdr) +
    iphdr->ihl * 4);

  switch (icmphdr->type)
  {
    case ICMP_ECHO:
     {
       if (protman_icmp_debug)
         printk("ip.c: icmp_rcv() ECHO REQUEST received.");

       icmp_echo_reply(buff, dev);
       break;
     }
     default:
     {
       printk("ip.c: icmp_rcv() ICMP Type 0x%X not supported in this kernel.",icmphdr->type);
       break;
     }
  }
}
